[06/19/2023]

A process is a "running program" or "program in execution"

Processes have a variety of states:

   RUNNING           READY                 WAITING (on I/O)
    STATE            STATE                  STATE

   +-----+                              +-------------------------+
   |     |     +--------------------+   |                         |
   | CPU | <== | P3 | P6 | P5 | ... |   | I/O Subsystem           |
   | P22 |     +--------------------+   |                         |
   +-----+                              +-------------------------+

-- a CPU burst is a set of assembly/machine instructions that are
    executed by the CPU for a given process, e.g., P22

-- an I/O burst is one or more I/O operations for a given process

-- process states:

   RUNNING STATE: process is actually using the CPU,
                   i.e., executing its instructions

   READY STATE: process is ready to use the CPU,
                 i.e., process is idle in the ready queue

   WAITING STATE: process is waiting for I/O operation(s) to complete


-- CPU Scheduling (a.k.a. Short-Term Scheduling)

   The scheduling system enables one process to use the CPU
    while the other processes are waiting in the ready queue to use
     the CPU (or waiting in the I/O Subsystem)

   The goals of CPU Scheduling are to make efficient use of the CPU
    and to minimize the turnaround and wait times for each process

    -- we also want to achieve "fairness" across all processes


Multiprogramming
-- In multiprogramming, several processes reside in memory
    at the same time
-- CPU is shared and managed by the OS
-- Addresses the problem of the CPU being under-utilized
-- But this introduces a new problem...
   ...need to perform a "context switch" to switch the CPU's
       context from one process to another

Processes in a multiprogramming system COMPETE for the CPU,
 but they also often need to COOPERATE with one another via IPC


Program Execution (process)
---------------------------
   |
   |
   v
 CPU burst
   |
   |
   v
 I/O burst
   |
   |
   v
 CPU burst
   |
   |
   v
 I/O burst
   |
   |
   v
 CPU burst
   |
   |
   v
 I/O burst
   |
   |
   v
 CPU burst
   |
   |
   v
 I/O burst
   |
   |
   v
 CPU burst
   |
   v
---------------------------
process termination...



A CPU-bound process is one that will primarily have
 longer CPU bursts (spending most of its time either
  running with the CPU or waiting in the ready queue
   until the CPU becomes available)
...a.k.a. compute-bound process

An I/O-bound process is one that will primarily have
 shorter CPU bursts (spending most of its time waiting
  on I/O operations to complete)
...a.k.a. interactive process



   +---------+ blocked +--------------------------+  +---------------+
P1 |CPU burst|---------|       CPU burst          |--|   CPU burst   |--->
   +---------+ on I/O  +--------------------------+  +---------------+


   +-----+     blocked on I/O                      +-----+
P2 | CPU |-----------------------------------------| CPU |--------------->
   |burst|                                         |burst|
   +-----+                                         +-----+


    P1 is a CPU-bound or compute-bound process

    P2 is an I/O-bound or interactive process


    We can model this as follows:
    -- Consider CPU usage from a probabilistic viewpoint
    -- Suppose processes spend fraction p of their time
        waiting for I/O to complete

    -- Given n processes in memory
        (i.e., the degree or multiprogramming is n),
         then the probability that all n processes
          are waiting for I/O is:

              n
             p

                                     n
    -- CPU utilization is then: 1 - p



Preemption occurs when the currently running process is
 preempted (i.e., kicked out) while using the CPU

 -- might be because a newly arriving (more important)
     process has entered the ready state

 -- might be because of a timeout (i.e., time-sharing)


A non-preemptive algorithm implies that when a process
 is using the CPU, it will use the CPU as long as necessary
  to complete its CPU burst


Four scenarios:
(1) running process "decides" that it is done with its CPU burst
     (e.g., read() or waitpid() or etc.)

(2) running process "decides" to terminate

(3) running process is interrupted (goes back to the ready state/queue)

(4) preemption?  running process is not done with its current CPU burst...
    ...another process enters the ready state and might preempt



Prioritizing processes:
-- batch: no users are waiting
    (lower priority --- non-preemptive)

-- interactive: users are waiting for a (quick) response;
    also servers serving up files/webpages/etc.
     (higher priority --- preemptive)

-- real-time: preemption is not usually necessary
    because processes already are designed to "know"
     that they need to run quickly




CPU scheduling criteria and measures include:
-- CPU utilization (busy versus idle CPU time)
-- Throughput
-- Fairness
-- Arrival and departure rates
-- Response times (minimize variance of response times)
-- Wait times
-- Turnaround times


*** For each CPU burst per each process:

WAIT TIME: How much time does a process spend in the
           ready queue, waiting for time with the CPU?
           (Note that the process here is in the READY state.)

TURNAROUND TIME: How much time is required for a process to
           complete its CPU burst, from the time it first enters
           the ready queue (i.e., the READY state) through to
           when it completes its CPU burst?

TURNAROUND TIME  =  WAIT TIME  +  CPU BURST TIME  +  OVERHEAD
                                                    (context switches)


First-Come-First-Served (FCFS)

  pid    CPU burst times
  P1       18 ms   <== CPU-bound process
  P2        3 ms   <== I/O-bound process
  P3        4 ms   <== I/O-bound process

  ready queue: P1 P2 P3

 (assume that all three processes arrived at time 0...)

   context switch       context switches
       v                  v   v    v      v
       +------------------+---+----+------+--------->
 FCFS: | P1               |P2 | P3 | idle | .......
       +------------------+---+----+------+--------->
    t: 0                  18  21   25

    P1 has 0 wait time         P1 has 18 ms turnaround time
    P2 has 18 ms wait time     P2 has 21 ms turnaround time
    P3 has 21 ms wait time     P3 has 25 ms turnaround time

-- When a process arrives or transitions to the ready state,
    we simply add it to the end of the READY queue

advantages: very simple; easy to implement; very low overhead

disadvantages: processes with larger CPU burst times will
                cause longer delays for other processes
                 (e.g., CPU-bound versus I/O-bound process mix)




