[07/10/2023]

Exam 1 --- average: ~70% --- stddev: ~11

Grade inquiries: open as of 11:59PM TODAY Jul 10
  (due within one week)


* * * * * * * * * *  SYNCHRONIZATION  * * * * * * * * * *

                  SHARED MEMORY
                 +-------------+
                 | shared x    | <== initially x is 5
                 +-------------+

  Process P1                      Process P2
+--------------+                +--------------+
|              |                |              |
| local y      |                | local z      | At <point A> and <point B>,
|              |                |              |  what is the value of x?
|              |                |              |
|              |                |              |
|--------------|                |--------------|
| x += 4       |                | x++          |
| y = x        |                | z = x        |
|--------------|                |--------------|
|              |                |              |
| print x      |                | print x      |
| print y      |                | print z      |
|              |                |              |
|              |                |              |
|  <point A>   |                |  <point B>   |
+--------------+                +--------------+

  What is x when BOTH processes reach <point A> and <point B>?

  <<< this is one possibility: >>>
      x == 5
  P1: x += 4  <-- x == 9
  P1: y = x   <-- y == 9
  P2: x++     <-- x == 10
  P2: z = x   <-- z == 10

  <<< this is another possibility: >>>
      x == 5
  P2: x++     <-- x == 6
  P2: z = x   <-- z == 6
  P1: x += 4  <-- x == 10
  P1: y = x   <-- y == 10

  <<< there are many more possibilities... >>>

  Local variables y and z can be 9, 6, 10, or ???

  Is it always going to be that x is 10 at the end...?

  e.g.,
      x == 5
  P1: x += 4  ------------->  x = x + 4

                              LOAD x   ; load the value of x into a register (5)
                              ADD #4   ; add 4 to that register (9)
                   <------context-switch-over-to-process-P2------>
                              STORE x  ; store the new value (9) back in x (shm)

  P2: x++  ---------------->  x = x + 1

                              LOAD x   ; load the value of x into a register (5)
                              INCR     ; add 1 to that register (6)
                              STORE x  ; store the new value (6) back in x (shm)
                   <------context-switch-over-to-process-P1------>

                The STORE x in P2 is overwritten by the STORE x in P1...

                   P1         LOAD x   ; load the value of x into a register (5)
                   P1         ADD #4   ; add 4 to that register (9)
                   <------context-switch-over-to-process-P2------>
                   P2         LOAD x   ; load the value of x into a register (5)
                   P2         INCR     ; add 1 to that register (6)
                   P2         STORE x  ; store the new value (6) back in x (shm)
                   <------context-switch-over-to-process-P1------>
                   P1         STORE x  ; store the new value (9) back in x (shm)






                  SHARED MEMORY
                 +-------------+
                 | shared x    | <== initially x is 5
                 +-------------+

  Process P1                      Process P2
+--------------+                +--------------+
|              |                |              |
| local y      |                | local z      | At <point A> and <point B>,
|              |                |              |  what is the value of x?
|              |                |              |
|              |                |              |
|--------------|                |--------------|
> x += 4       < CRITICAL       > x++          <
> y = x        < SECTIONS for x > z = x        <
|--------------|                |--------------|
|              |                |              |
| print x      |                | print x      |
| print y      |                | print z      |
|              |                |              |
|              |                |              |
|  <point A>   |                |  <point B>   |
+--------------+                +--------------+

The highlighted CRITICAL SECTIONS are shown above

-- to synchronize these two processes, only one (and no more than one)
    process can be in its critical section at any given time

A CRITICAL SECTION guarantees MUTUAL EXCLUSION among multiple processes
 for access to one or more shared resources, e.g., shared variable x

To synchronize processes, first we must identify the critical sections
 of code within each process

-- the OS must control access to the critical sections by providing us
    (as programmers) some mechanism to define these critical sections, etc.
    -- e.g., semaphores







Multiple threads
-- in ONE process, we can have multiple threads of execution

   ONE PROCESS ./a.out
  +---------------------------------+
  |           main()                |
  |             |                   |
  |             |                   |
  |             v                   |
  |                                 |
  |      create a few threads...    |
  |                                 |
  | thread1   thread2     thread3   |
  |   |          |           |      |
  |   |         /            |      |
  |   |        |              \     |  e.g., if thread2 crashes (seg-faults), then
  |  /          \              \    |         all threads are dead...the process ends
  | |            \              |   |
  | |             v             v   |
  | v                               |
  |                                 |
  |                                 |
  | these threads join() back in    |
  |  to the parent thread           |
  |                                 |
  |                                 |
  |                                 |
  +---------------------------------+

